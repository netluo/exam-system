# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'ob-examine.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import collections
import random

from PyQt5.QtWidgets import QApplication, QStyleFactory

from examine.db.db import MysqlConnMgr
from examine.db.openexcel import ManExcel
from examine.ui.ob_examine import Ui_MainWindow

qid_list_done = []  # 已经答过的题列表和当时选择的答案
answer_dict = {}
current_question = {}
current_options = {}


class MainLogic:
    def __init__(self):
        self.qid = 0
        self.qid_done = collections.OrderedDict()  # 有序字典，用来存放已经做了的题和当时的选项
        self.exam_done = {}  # 题目做完提交后，存放题目的评阅结果
        self.qid_list = []
        self.wrong_dict = {}

    def from_excel(self):
        filename = MainUI.get_filename()
        ManExcel.readExcel(filename)

    def get_qid(self):
        if len(self.qid_list) > 1:
            MainUI.nextButton.setText('Next')
        elif len(self.qid_list) == 1:
            MainUI.nextButton.setText('Commit')
            MainUI.nextButton.clicked.disconnect(self.get_next_question)
            MainUI.nextButton.clicked.connect(self.q_commit)
        else:
            self.qid_list = random.sample(range(mgr.qid_range[1][0], mgr.qid_range[1][1]), 10) + random.sample(
                range(mgr.qid_range[2][0], mgr.qid_range[2][1]), 5) + random.sample(
                range(mgr.qid_range[3][0], mgr.qid_range[3][1]), 5)
            MainUI.nextButton.clicked.disconnect(self.q_commit)
            MainUI.nextButton.clicked.connect(self.get_next_question)
        self.qid_idx = random.randint(0, len(self.qid_list) - 1)
        self.qid = self.qid_list.pop(self.qid_idx)  # qid : question id
        return self.from_db(self.qid)

    def from_db(self, qid):
        questions = mgr.questionSelect(qid)
        _answers = mgr.getAnswer(qid)
        answer_dict.update({qid: _answers})
        MainUI.nextButton.setEnabled(True)
        return MainUI.add_question(mgr.getOptions(questions))

    def judge_option(self):
        for qid in self.qid_done.keys():
            right_answer = list(answer_dict[qid])
            if len(self.qid_done[qid]) == len(right_answer):
                if self.qid_done[qid] == right_answer:
                    self.exam_done.update({qid: '✓'})
                    try:
                        self.wrong_dict.pop(qid)
                    except Exception:
                        pass
                else:
                    self.exam_done.update({qid: '✗'})
                    self.wrong_dict.update({qid: answer_dict[qid]})
            else:
                self.exam_done.update({qid: '✗'})
                self.wrong_dict.update({qid: answer_dict[qid]})
        MainUI.textBrowser.setText(self.exam_done.__str__())

    def get_next_question(self):
        _list_done_tmp = []  # 临时存放当前题目的答案
        _list_done_tmp.clear()
        for option_name in MainUI.current_options.keys():
            MainUI.verticalLayout.removeWidget(MainUI.current_options[option_name])
            #     把widget从布局中移除后, 还需要对这个widget使用setParent(null)
            MainUI.current_options[option_name].setParent(None)
            if MainUI.current_options[option_name].isChecked():
                _list_done_tmp.append(option_name)
        self.qid_done.update({self.qid: _list_done_tmp})
        qid_list_done.append(self.qid)
        # print(self.qid_done)  # [{3001: ['A']}, {1003: ['B']}]

        self.get_qid()
        if len(self.qid_done) > 0:
            MainUI.preButton.setEnabled(True)
        # if len(self.qid_list) == 0:
        #     MainUI.nextButton.setText('Commit')
        #     MainUI.nextButton.clicked.disconnect(self.get_next_question)
        #     MainUI.nextButton.clicked.connect(self.q_commit)

    def q_commit(self):
        _list_done_tmp = []
        for option_name in MainUI.current_options.keys():
            if MainUI.current_options[option_name].isChecked():
                _list_done_tmp.append(option_name)
            MainUI.verticalLayout.removeWidget(MainUI.current_options[option_name])
            MainUI.current_options[option_name].setParent(None)
        self.qid_done.update({self.qid: _list_done_tmp})
        qid_list_done.append(self.qid)
        self.judge_option()
        MainUI.nextButton.setDisabled(True)

    def get_pre_question(self):
        for option_name in MainUI.current_options.keys():
            MainUI.verticalLayout.removeWidget(MainUI.current_options[option_name])
            # 把widget从布局中移除后, 还需要对这个widget使用setParent(null)
            MainUI.current_options[option_name].setParent(None)
        self.qid_list.insert(self.qid_idx, self.qid)
        if len(qid_list_done) > 0:
            self.qid = qid_list_done.pop()
            self.from_db(self.qid)
        for option_name in self.qid_done[self.qid]:
            MainUI.current_options[option_name].setChecked(True)

    def get_wrong_question(self):
        if len(self.wrong_dict) > 0:
            for wrong_qid in self.wrong_dict.keys():
                self.qid_list.append(wrong_qid)
            # MainUI.nextButton.clicked.disconnect(self.q_commit)
            MainUI.nextButton.clicked.connect(self.get_next_question)
            self.get_qid()
        else:
            pass


if __name__ == "__main__":
    import sys

    main_logic = MainLogic()
    mgr = MysqlConnMgr('lcx', 'root123', '192.168.32.128', 3306, 'mysqlexamine')
    main_logic.qid_list = random.sample(range(1110, 1124), 10)
    app = QApplication(sys.argv)
    app.setStyle(QStyleFactory.create('fusion'))
    MainUI = Ui_MainWindow()
    MainUI.actionfrom_db.triggered.connect(main_logic.get_qid)
    MainUI.nextButton.clicked.connect(main_logic.get_next_question)
    MainUI.preButton.clicked.connect(main_logic.get_pre_question)
    MainUI.actioncommit.triggered.connect(main_logic.judge_option)
    MainUI.actionfrom_qid.triggered.connect(main_logic.get_wrong_question)
    MainUI.show()
    sys.exit(app.exec_())
